{"ast":null,"code":"import { useCallback, useRef, useReducer } from 'react';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _toPropertyKey(key) {\n  if (typeof key === \"symbol\") {\n    return key;\n  } else {\n    return String(key);\n  }\n}\n/**\n * Returns a function that can be called with an object. The return value of the\n * new function is a copy of the object excluding the key passed initially.\n */\n\n\nfunction omit(key) {\n  return function (object) {\n    var toRemove = object[key],\n        rest = _objectWithoutProperties(object, [key].map(_toPropertyKey));\n\n    return rest;\n  };\n}\n/**\n * An empty function. It does nothing.\n */\n\n\nfunction noop() {}\n/**\n * Like `noop`, but passes through the first argument.\n */\n\n\nfunction identity(val) {\n  return val;\n}\n/**\n * Cast non-string values to a string, with the exception of functions, symbols,\n * and undefined.\n */\n\n\nfunction toString(value) {\n  switch (_typeof(value)) {\n    case 'function':\n    case 'symbol':\n    case 'undefined':\n      return '';\n\n    default:\n      return '' + value;\n    // eslint-disable-line prefer-template\n  }\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nvar objectToString = function objectToString(value) {\n  return Object.prototype.toString.call(value);\n};\n/**\n * Determines if a value is an empty collection (object, array, string, map, set)\n * @note this returns false for anything else.\n */\n\n\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n\n  if (Array.isArray(value) || typeof value === 'string') {\n    return !value.length;\n  }\n\n  if (objectToString(value) === '[object Map]' || objectToString(value) === '[object Set]') {\n    return !value.size;\n  }\n\n  if (objectToString(value) === '[object Object]') {\n    return !Object.keys(value).length;\n  }\n\n  return false;\n}\n\nvar defaultInputOptions = {\n  onChange: identity,\n  onBlur: noop,\n  validate: null,\n  validateOnBlur: false,\n  touchOnChange: false\n};\n\nfunction parseInputArgs(args) {\n  var name;\n  var ownValue;\n  var options;\n\n  if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n    var _args = _slicedToArray(args, 2);\n\n    name = _args[0];\n    ownValue = _args[1];\n  } else {\n    var _args2 = _slicedToArray(args, 1);\n\n    var _args2$ = _args2[0];\n    name = _args2$.name;\n    ownValue = _args2$.value;\n    options = _objectWithoutProperties(_args2$, [\"name\", \"value\"]);\n  }\n\n  return _objectSpread({\n    name: name,\n    ownValue: ownValue\n  }, defaultInputOptions, options);\n}\n\nvar defaultCreateId = function defaultCreateId(name, value) {\n  return ['__ufs', name, value].filter(Boolean).join('__');\n};\n\nfunction useInputId(implementation) {\n  var getId = useCallback(function (name, ownValue) {\n    var createId;\n\n    if (!implementation) {\n      createId = noop;\n    } else if (isFunction(implementation)) {\n      createId = implementation;\n    } else {\n      createId = defaultCreateId;\n    }\n\n    var value = toString(ownValue);\n    return value ? createId(name, value) : createId(name);\n  }, [implementation]);\n  var getIdProp = useCallback(function (prop, name, value) {\n    var id = getId(name, value);\n    return id === undefined ? {} : _defineProperty({}, prop, id);\n  }, [getId]);\n  return {\n    getIdProp: getIdProp\n  };\n}\n\nfunction useCache() {\n  var cache = useRef(new Map());\n\n  var has = function has(key) {\n    return cache.current.has(key);\n  };\n\n  var get = function get(key) {\n    return cache.current.get(key);\n  };\n\n  var set = function set(key, value) {\n    return cache.current.set(key, value);\n  };\n\n  var getOrSet = function getOrSet(key, value) {\n    return has(key) ? get(key) : set(key, value) && get(key);\n  };\n\n  return {\n    getOrSet: getOrSet,\n    set: set,\n    has: has,\n    get: get\n  };\n}\n\nfunction stateReducer(state, newState) {\n  return isFunction(newState) ? newState(state) : _objectSpread({}, state, newState);\n}\n\nfunction useState(_ref) {\n  var initialState = _ref.initialState,\n      onClear = _ref.onClear,\n      onReset = _ref.onReset;\n  var state = useRef();\n  var initialValues = useCache();\n\n  var _useReducer = useReducer(stateReducer, initialState || {}),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      values = _useReducer2[0],\n      setValues = _useReducer2[1];\n\n  var _useReducer3 = useReducer(stateReducer, {}),\n      _useReducer4 = _slicedToArray(_useReducer3, 2),\n      touched = _useReducer4[0],\n      setTouched = _useReducer4[1];\n\n  var _useReducer5 = useReducer(stateReducer, {}),\n      _useReducer6 = _slicedToArray(_useReducer5, 2),\n      validity = _useReducer6[0],\n      setValidity = _useReducer6[1];\n\n  var _useReducer7 = useReducer(stateReducer, {}),\n      _useReducer8 = _slicedToArray(_useReducer7, 2),\n      errors = _useReducer8[0],\n      setError = _useReducer8[1];\n\n  state.current = {\n    values: values,\n    touched: touched,\n    validity: validity,\n    errors: errors\n  };\n\n  function _setField(name, value, inputValidity, inputTouched, inputError) {\n    setValues(_defineProperty({}, name, value));\n    setTouched(_defineProperty({}, name, inputTouched));\n    setValidity(_defineProperty({}, name, inputValidity));\n    setError(_defineProperty({}, name, inputError));\n  }\n\n  var clearField = function clearField(name) {\n    return _setField(name);\n  };\n\n  var resetField = function resetField(name) {\n    return _setField(name, initialValues.get(name));\n  };\n\n  return {\n    /**\n     * @type {{ values, touched, validity, errors }}\n     */\n    get current() {\n      return state.current;\n    },\n\n    setValues: setValues,\n    setTouched: setTouched,\n    setValidity: setValidity,\n    setError: setError,\n    initialValues: initialValues,\n    controls: {\n      clearField: clearField,\n      resetField: resetField,\n      clear: function clear() {\n        Object.keys(state.current.values).forEach(clearField);\n        onClear();\n      },\n      reset: function reset() {\n        Object.keys(state.current.values).forEach(resetField);\n        onReset();\n      },\n      setField: function setField(name, value) {\n        _setField(name, value, true, true);\n      },\n      setFieldError: function setFieldError(name, error) {\n        setValidity(_defineProperty({}, name, false));\n        setError(_defineProperty({}, name, error));\n      }\n    }\n  };\n}\n\nvar CHECKBOX = 'checkbox';\nvar COLOR = 'color';\nvar DATE = 'date';\nvar EMAIL = 'email';\nvar MONTH = 'month';\nvar NUMBER = 'number';\nvar PASSWORD = 'password';\nvar RADIO = 'radio';\nvar RANGE = 'range';\nvar RAW = 'raw';\nvar SEARCH = 'search';\nvar SELECT = 'select';\nvar SELECT_MULTIPLE = 'selectMultiple';\nvar TEL = 'tel';\nvar TEXT = 'text';\nvar TEXTAREA = 'textarea';\nvar TIME = 'time';\nvar URL = 'url';\nvar WEEK = 'week';\nvar LABEL = 'label';\nvar TYPES = [CHECKBOX, COLOR, DATE, EMAIL, MONTH, NUMBER, PASSWORD, RADIO, RANGE, RAW, SEARCH, SELECT, SELECT_MULTIPLE, TEL, TEXT, TEXTAREA, TIME, URL, WEEK];\nvar ON_CHANGE_HANDLER = 0;\nvar ON_BLUR_HANDLER = 1;\nvar CONSOLE_TAG = '[useFormState]';\nvar defaultFormOptions = {\n  onBlur: noop,\n  onChange: noop,\n  onClear: noop,\n  onReset: noop,\n  onTouched: noop,\n  withIds: false\n};\n\nfunction useFormState(initialState, options) {\n  var formOptions = _objectSpread({}, defaultFormOptions, options);\n\n  var formState = useState(_objectSpread({\n    initialState: initialState\n  }, formOptions));\n\n  var _useInputId = useInputId(formOptions.withIds),\n      getIdProp = _useInputId.getIdProp;\n\n  var _useCache = useCache(),\n      setDirty = _useCache.set,\n      isDirty = _useCache.has;\n\n  var callbacks = useCache();\n  var devWarnings = useCache();\n\n  function warn(key, type, message) {\n    if (!devWarnings.has(\"\".concat(type, \":\").concat(key))) {\n      devWarnings.set(\"\".concat(type, \":\").concat(key), true); // eslint-disable-next-line no-console\n\n      console.warn(CONSOLE_TAG, message);\n    }\n  }\n\n  var createPropsGetter = function createPropsGetter(type) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var _parseInputArgs = parseInputArgs(args),\n          name = _parseInputArgs.name,\n          ownValue = _parseInputArgs.ownValue,\n          inputOptions = _objectWithoutProperties(_parseInputArgs, [\"name\", \"ownValue\"]);\n\n      var hasOwnValue = !!toString(ownValue);\n      var isCheckbox = type === CHECKBOX;\n      var isRadio = type === RADIO;\n      var isSelectMultiple = type === SELECT_MULTIPLE;\n      var isRaw = type === RAW;\n      var hasValueInState = formState.current.values[name] !== undefined; // This is used to cache input props that shouldn't change across\n      // re-renders.  Note that for `raw` values, `toString(ownValue)`\n      // will return '[object Object]'.  This means we can't have multiple\n      // raw inputs with the same name and different values, but this is\n      // probably fine.\n\n      var key = \"\".concat(type, \".\").concat(name, \".\").concat(toString(ownValue));\n\n      function setDefaultValue() {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV === 'development') {\n          if (isRaw && formState.current.values[name] === undefined) {\n            warn(key, 'missingInitialValue', \"The initial value for input \\\"\".concat(name, \"\\\" is missing. Custom inputs \") + 'controlled with raw() are expected to have an initial value ' + 'provided to useFormState(). To prevent React from treating ' + 'this input as uncontrolled, an empty string will be used instead.');\n          }\n        }\n\n        var value = '';\n\n        if (isCheckbox) {\n          /**\n           * If a checkbox has a user-defined value, its value the form state\n           * value will be an array. Otherwise it will be considered a toggle.\n           */\n          value = hasOwnValue ? [] : false;\n        }\n\n        if (isSelectMultiple) {\n          value = [];\n        }\n\n        formState.setValues(_defineProperty({}, name, value));\n      }\n\n      function getNextCheckboxValue(e) {\n        var _e$target = e.target,\n            value = _e$target.value,\n            checked = _e$target.checked;\n\n        if (!hasOwnValue) {\n          return checked;\n        }\n\n        var checkedValues = new Set(formState.current.values[name]);\n\n        if (checked) {\n          checkedValues.add(value);\n        } else {\n          checkedValues.delete(value);\n        }\n\n        return Array.from(checkedValues);\n      }\n\n      function getNextSelectMultipleValue(e) {\n        return Array.from(e.target.options).reduce(function (values, option) {\n          return option.selected ? _toConsumableArray(values).concat([option.value]) : values;\n        }, []);\n      }\n\n      function validate(e) {\n        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isRaw ? formState.current.values[name] : e.target.value;\n        var values = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : formState.current.values;\n        var error;\n        var isValid = true;\n        /* istanbul ignore else */\n\n        if (isFunction(inputOptions.validate)) {\n          var result = inputOptions.validate(value, values, e);\n\n          if (result !== true && result != null) {\n            isValid = false;\n            error = result !== false ? result : '';\n          }\n        } else if (!isRaw) {\n          isValid = e.target.validity.valid;\n          error = e.target.validationMessage;\n        } else if (process.env.NODE_ENV === 'development') {\n          warn(key, 'missingValidate', \"You used a raw input type for \\\"\".concat(name, \"\\\" without providing a \") + 'custom validate method. As a result, validation of this input ' + 'will be set to \"true\" automatically. If you need to validate ' + 'this input, provide a custom validation option.');\n        }\n\n        formState.setValidity(_defineProperty({}, name, isValid));\n        formState.setError(isEmpty(error) ? omit(name) : _defineProperty({}, name, error));\n      }\n\n      function touch(e) {\n        if (!formState.current.touched[name]) {\n          formState.setTouched(_defineProperty({}, name, true));\n          formOptions.onTouched(e);\n        }\n      }\n\n      var inputProps = _objectSpread({\n        name: name,\n\n        get type() {\n          if (type !== SELECT && type !== SELECT_MULTIPLE && type !== TEXTAREA) {\n            return type;\n          }\n        },\n\n        get multiple() {\n          if (type === SELECT_MULTIPLE) {\n            return true;\n          }\n        },\n\n        get checked() {\n          var values = formState.current.values;\n\n          if (isRadio) {\n            return values[name] === toString(ownValue);\n          }\n\n          if (isCheckbox) {\n            if (!hasOwnValue) {\n              return values[name] || false;\n            }\n            /**\n             * @todo Handle the case where two checkbox inputs share the same\n             * name, but one has a value, the other doesn't (throws currently).\n             * <input {...input.checkbox('option1')} />\n             * <input {...input.checkbox('option1', 'value_of_option1')} />\n             */\n\n\n            return hasValueInState ? values[name].includes(toString(ownValue)) : false;\n          }\n        },\n\n        get value() {\n          if (!hasValueInState) {\n            // auto populating default values if an initial value is not provided\n            setDefaultValue();\n          } else if (!formState.initialValues.has(name)) {\n            // keep track of user-provided initial values on first render\n            formState.initialValues.set(name, formState.current.values[name]);\n          } // auto populating default values of touched\n\n\n          if (formState.current.touched[name] == null) {\n            formState.setTouched(_defineProperty({}, name, false));\n          }\n          /**\n           * Since checkbox and radio inputs have their own user-defined values,\n           * and since checkbox inputs can be either an array or a boolean,\n           * returning the value of input from the current form state is illogical\n           */\n\n\n          if (isCheckbox || isRadio) {\n            return toString(ownValue);\n          }\n\n          return hasValueInState ? formState.current.values[name] : '';\n        },\n\n        onChange: callbacks.getOrSet(ON_BLUR_HANDLER + key, function (e) {\n          setDirty(name, true);\n          var value;\n\n          if (isRaw) {\n            value = inputOptions.onChange(e);\n\n            if (value === undefined) {\n              // setting value to its current state if onChange does not return\n              // value to prevent React from complaining about the input switching\n              // from controlled to uncontrolled\n              value = formState.current.values[name];\n              /* istanbul ignore else */\n\n              if (process.env.NODE_ENV === 'development') {\n                warn(key, 'onChangeUndefined', \"You used a raw input type for \\\"\".concat(name, \"\\\" with an onChange() \") + 'option without returning a value. The onChange callback ' + 'of raw inputs, when provided, is used to determine the ' + 'custom value that will be stored in the form state. ' + 'Therefore, a value must be returned from the onChange callback.');\n              }\n            }\n          } else {\n            if (isCheckbox) {\n              value = getNextCheckboxValue(e);\n            } else if (isSelectMultiple) {\n              value = getNextSelectMultipleValue(e);\n            } else {\n              value = e.target.value;\n            }\n\n            inputOptions.onChange(e);\n          } // Mark raw fields as touched on change, since we might not get an\n          // `onBlur` event from them.\n\n\n          if (inputOptions.touchOnChange) {\n            touch(e);\n          }\n\n          var partialNewState = _defineProperty({}, name, value);\n\n          var newValues = _objectSpread({}, formState.current.values, partialNewState);\n\n          formOptions.onChange(e, formState.current.values, newValues);\n\n          if (!inputOptions.validateOnBlur) {\n            validate(e, value, newValues);\n          }\n\n          formState.setValues(partialNewState);\n        }),\n        onBlur: callbacks.getOrSet(ON_CHANGE_HANDLER + key, function (e) {\n          touch(e);\n          inputOptions.onBlur(e);\n          formOptions.onBlur(e);\n          /**\n           * Limiting input validation on blur to:\n           * A) when it's either touched for the first time\n           * B) when it's marked as dirty due to a value change\n           */\n\n          /* istanbul ignore else */\n\n          if (!formState.current.touched[name] || isDirty(name)) {\n            validate(e);\n            setDirty(name, false);\n          }\n        })\n      }, getIdProp('id', name, ownValue));\n\n      return isRaw ? {\n        onChange: inputProps.onChange,\n        onBlur: inputProps.onBlur,\n        value: inputProps.value\n      } : inputProps;\n    };\n  };\n\n  var inputPropsCreators = TYPES.reduce(function (methods, type) {\n    return _objectSpread({}, methods, _defineProperty({}, type, createPropsGetter(type)));\n  }, {});\n  return [_objectSpread({}, formState.current, formState.controls), _objectSpread({}, inputPropsCreators, _defineProperty({}, LABEL, function (name, ownValue) {\n    return getIdProp('htmlFor', name, ownValue);\n  }))];\n}\n\nexport { useFormState };","map":null,"metadata":{},"sourceType":"module"}